# Notes for Angular - 01 Architecture and workflow of angular
> **by youhengchan**
## Overview
* The architecture of Angular will be an app contains one more modules
* Each module contains one or more components and services
* Each component contains an HTML template and a class to control the logic for that particular view  
* Module can also have services which contains the business logic of the app.
* Modules export and import code as when required and finally render the view in the browser
## App structure  
![Angular App Structure](https://i.imgur.com/RtFLoWD.png)    
### **package.json**
    {
      "name": "angulartest",
      "version": "0.0.0",
      "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "test": "ng test",
    "lint": "ng lint",
    "e2e": "ng e2e"
      },
      "private": true,
      "dependencies": {
    "@angular/animations": "~8.2.14",
    "@angular/common": "~8.2.14",
    "@angular/compiler": "~8.2.14",
    "@angular/core": "~8.2.14",
    "@angular/forms": "~8.2.14",
    "@angular/platform-browser": "~8.2.14",
    "@angular/platform-browser-dynamic": "~8.2.14",
    "@angular/router": "~8.2.14",
    "rxjs": "~6.4.0",
    "tslib": "^1.10.0",
    "zone.js": "~0.9.1"
      },
      "devDependencies": {
    "@angular-devkit/build-angular": "~0.803.24",
    "@angular/cli": "~8.3.24",
    "@angular/compiler-cli": "~8.2.14",
    "@angular/language-service": "~8.2.14",
    "@types/jasmine": "~3.3.8",
    "@types/jasminewd2": "~2.0.3",
    "@types/jquery": "^3.3.31",
    "@types/node": "~8.9.4",
    "codelyzer": "^5.0.0",
    "jasmine-core": "~3.4.0",
    "jasmine-spec-reporter": "~4.2.1",
    "karma": "~4.1.0",
    "karma-chrome-launcher": "~2.2.0",
    "karma-coverage-istanbul-reporter": "~2.0.1",
    "karma-jasmine": "~2.0.1",
    "karma-jasmine-html-reporter": "^1.4.0",
    "protractor": "~5.4.0",
    "ts-node": "~7.0.0",
    "tslint": "~5.15.0",
    "typescript": "~3.5.3"
      }
    }
There are 3 categories in the above:  
1. **dependencies**  
2. **devdependencies**  
(dev : development)  
3. **scriptes**  
(Command that will be excuted)  
`"start": "ng serve"`  
means that `npm start` => `ng serve`  

And there other two properties of the app:  
1. **name**  
2. **version**    

## Source Folder
![src-folder](https://i.imgur.com/v8xDdPu.png)  
Source folder is the one that we concerned with most of the time in the series.  
In the source folder showed above, there are two componeted that I generated by Angular CLI CMD:  
`ng g component components/news`  
and  
`ng g component components/news1`  
That two CMDs then generated the two componets named news and news1 stored the output files in the dir : `src/components/news(news1)`  
### main.ts  
main.ts file is the enter point to our angular project.  

### app.modules.ts  
This file is contained in the app folder which is the sub-dir of the src folder. And this file - **app.modules.ts** is the root module
of our application.  

### app.components.ts
This is the root component of the application.

## workflow  

### 1. main.ts
When we type the CMD : `ng serve` in the CLI, the execution comes to the main.ts file. Then the main.ts file will bootstrap (kickstart) the app module, `main.ts` :
	
	// main.ts
    import { enableProdMode } from '@angular/core';
    import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
    
    import { AppModule } from './app/app.module';
    import { environment } from './environments/environment';
    
    if (environment.production) {
      enableProdMode();
    }
    
    platformBrowserDynamic().bootstrapModule(AppModule)
      .catch(err => console.error(err));
    
From the code above, you can find that 
main.ts can decide if it's the production environment or just development environment.  
And then it will call the bootstrap method through : 

    platformBrowserDynamic().bootstrapModule(AppModule)
    .catch(err => console.error(err));
 
and then call the AppModule.  

### 2. app.modules.ts
This is the root module of the application.  
As we can see in the main.ts : `import { AppModule } from './app/app.module';` , the AppModule is exactly exported from the './app/app.modules' which means from this file (app.modules.ts) :
 

	// app.modules.ts
    import { BrowserModule } from '@angular/platform-browser';
    import { NgModule } from '@angular/core';
    
    import { AppRoutingModule } from './app-routing.module';
    import { AppComponent } from './app.component';
    // 这是创建组件之后自动添加的
    import { NewsComponent } from './components/news/news.component';
    import { News1Component } from './components/news1/news1.component';
    
    @NgModule({
      declarations: [
    AppComponent,
    NewsComponent,  // 创建组件后自动添加的
    News1Component  // 创建组件后自动添加的
      ],
      imports: [
    BrowserModule,
    AppRoutingModule
      ],
      providers: [],
      bootstrap: [AppComponent]
    })
    export class AppModule { }  // 根组件不用向外部提供接口

In this file (app.modules.ts), you can find it at first import the outside modules and then use the class decorator - **NgModule** to decorate the  class - **AppModule**:  
	
	// parameters of the decorator
    {
      declarations: [
    AppComponent,
    NewsComponent,  // 创建组件后自动添加的
    News1Component  // 创建组件后自动添加的
      ],
      imports: [
    BrowserModule,
    AppRoutingModule
      ],
      providers: [],
      bootstrap: [AppComponent]
    }


And if we dive deeper into the decorator and get to learn the other parameters of the **NgModule**, we can go to the definition of the decorator - **NgModule** :
    
	// angulartest/node_modules/@angular/core 
    export declare interface NgModule {
    /**
     * The set of injectable objects that are available in the injector
     * of this module.
     *
     * @see [Dependency Injection guide](guide/dependency-injection)
     * @see [NgModule guide](guide/providers)
     *
     * @usageNotes
     *
     * Dependencies whose providers are listed here become available for injection
     * into any component, directive, pipe or service that is a child of this injector.
     * The NgModule used for bootstrapping uses the root injector, and can provide dependencies
     * to any part of the app.
     *
     * A lazy-loaded module has its own injector, typically a child of the app root injector.
     * Lazy-loaded services are scoped to the lazy-loaded module's injector.
     * If a lazy-loaded module also provides the `UserService`, any component created
     * within that module's context (such as by router navigation) gets the local instance
     * of the service, not the instance in the root injector.
     * Components in external modules continue to receive the instance provided by their injectors.
     *
     * ### Example
     *
     * The following example defines a class that is injected in
     * the HelloWorld NgModule:
     *
     * ```
     * class Greeter {
     *greet(name:string) {
     *  return 'Hello ' + name + '!';
     *}
     * }
     *
     * @NgModule({
     *   providers: [
     * Greeter
     *   ]
     * })
     * class HelloWorld {
     *   greeter:Greeter;
     *
     *   constructor(greeter:Greeter) {
     * this.greeter = greeter;
     *   }
     * }
     * ```
     */
    providers?: Provider[];
    /**
     * The set of components, directives, and pipes ([declarables](guide/glossary#declarable))
     * that belong to this module.
     *
     * @usageNotes
     *
     * The set of selectors that are available to a template include those declared here, and
     * those that are exported from imported NgModules.
     *
     * Declarables must belong to exactly one module.
     * The compiler emits an error if you try to declare the same class in more than one module.
     * Be careful not to declare a class that is imported from another module.
     *
     * ### Example
     *
     * The following example allows the CommonModule to use the `NgFor`
     * directive.
     *
     * ```javascript
     * @NgModule({
     *   declarations: [NgFor]
     * })
     * class CommonModule {
     * }
     * ```
     */
    declarations?: Array<Type<any> | any[]>;
    /**
     * The set of NgModules whose exported [declarables](guide/glossary#declarable)
     * are available to templates in this module.
     *
     * @usageNotes
     *
     * A template can use exported declarables from any
     * imported module, including those from modules that are imported indirectly
     * and re-exported.
     * For example, `ModuleA` imports `ModuleB`, and also exports
     * it, which makes the declarables from `ModuleB` available
     * wherever `ModuleA` is imported.
     *
     * ### Example
     *
     * The following example allows MainModule to use anything exported by
     * `CommonModule`:
     *
     * ```javascript
     * @NgModule({
     *   imports: [CommonModule]
     * })
     * class MainModule {
     * }
     * ```
     *
     */
    imports?: Array<Type<any> | ModuleWithProviders<{}> | any[]>;
    /**
     * The set of components, directives, and pipes declared in this
     * NgModule that can be used in the template of any component that is part of an
     * NgModule that imports this NgModule. Exported declarations are the module's public API.
     *
     * A declarable belongs to one and only one NgModule.
     * A module can list another module among its exports, in which case all of that module's
     * public declaration are exported.
     *
     * @usageNotes
     *
     * Declarations are private by default.
     * If this ModuleA does not export UserComponent, then only the components within this
     * ModuleA can use UserComponent.
     *
     * ModuleA can import ModuleB and also export it, making exports from ModuleB
     * available to an NgModule that imports ModuleA.
     *
     * ### Example
     *
     * The following example exports the `NgFor` directive from CommonModule.
     *
     * ```javascript
     * @NgModule({
     *   exports: [NgFor]
     * })
     * class CommonModule {
     * }
     * ```
     */
    exports?: Array<Type<any> | any[]>;
    /**
     * The set of components to compile when this NgModule is defined,
     * so that they can be dynamically loaded into the view.
     *
     * For each component listed here, Angular creates a `ComponentFactory`
     * and stores it in the `ComponentFactoryResolver`.
     *
     * Angular automatically adds components in the module's bootstrap
     * and route definitions into the `entryComponents` list. Use this
     * option to add components that are bootstrapped
     * using one of the imperative techniques, such as `ViewContainerRef.createComponent()`.
     *
     * @see [Entry Components](guide/entry-components)
     */
    entryComponents?: Array<Type<any> | any[]>;
    /**
     * The set of components that are bootstrapped when
     * this module is bootstrapped. The components listed here
     * are automatically added to `entryComponents`.
     */
    bootstrap?: Array<Type<any> | any[]>;
    /**
     * The set of schemas that declare elements to be allowed in the NgModule.
     * Elements and properties that are neither Angular components nor directives
     * must be declared in a schema.
     *
     * Allowed value are `NO_ERRORS_SCHEMA` and `CUSTOM_ELEMENTS_SCHEMA`.
     *
     * @security When using one of `NO_ERRORS_SCHEMA` or `CUSTOM_ELEMENTS_SCHEMA`
     * you must ensure that allowed elements and properties securely escape inputs.
     */
    schemas?: Array<SchemaMetadata | any[]>;
    /**
     * A name or path that uniquely identifies this NgModule in `getModuleFactory`.
     * If left `undefined`, the NgModule is not registered with
     * `getModuleFactory`.
     */
    id?: string;
    /**
     * If true, this module will be skipped by the AOT compiler and so will always be compiled
     * using JIT.
     *
     * This exists to support future Ivy work and has no effect currently.
     */
    jit?: true;
    }

And you can find another two exported module:

    //  angulartest/node_modules/@angular/core 
	export declare const NgModule: NgModuleDecorator;

and
	
	//  angulartest/node_modules/@angular/core 
    /**
     * Type of the NgModule decorator / constructor function.
     *
     * @publicApi
     */
    export declare interface NgModuleDecorator {
    /**
     * Decorator that marks a class as an NgModule and supplies configuration metadata.
     */
    (obj?: NgModule): TypeDecorator;
    new (obj?: NgModule): NgModule;
    }

From the above three code clips, we now move back to the real code:  


    @NgModule({
      declarations: [
    AppComponent,
    NewsComponent,  // 创建组件后自动添加的
    News1Component  // 创建组件后自动添加的
      ],
      imports: [
    BrowserModule,
    AppRoutingModule
      ],
      providers: [],
      bootstrap: [AppComponent]
    })
    
The @NgModule takes an object with following parameter categories : ` declarations | imports | providers | bootstrap | schema | jit | entryComponents `  
### **Summary**
* **providers** : The set of injectable objects that are available in the injector of this module.  
*format* : `providers?: Provider[];`  
* **imports** : The set of NgModules whose exported [declarables](guide/glossary#declarable) are available to templates in this module.  
*format* : `imports?: Array<Type<any> | ModuleWithProviders<{}> | any[]>;`  
* **bootstraps** ： The set of components that are bootstrapped when this module is bootstrapped. The components listed here are automatically added to `entryComponents`.  
*format* : `bootstrap?: Array<Type<any> | any[]>;`  
* **declaration** : The set of components, directives, and pipes ([declarables](guide/glossary#declarable)) that belong to this module.
*format* : `declarations?: Array<Type<any> | any[]>;`  
* **jit** : This exists to support future Ivy work and has no effect currently.  
*format* : `jit?: true;`  
* **entryComponents** : The set of components to compile when this NgModule is defined, so that they can be dynamically loaded into the view.  
format : `entryComponents?: Array<Type<any> | any[]>;`  
* **schemas** :  The set of schemas that declare elements to be allowed in the NgModule. Elements and properties that are neither Angular components nor directives must be declared in a schema.
*format* : `schemas?: Array<SchemaMetadata | any[]>;` 

### 3. app.component.ts  
This is the root component of the application.  
The app.modules.ts will call the  AppComponent (from `bootstrap: [AppComponent]`) which is just this file :  
 
    // app.component.ts
	import { Component } from '@angular/core';
    
    @Component({
      selector: 'app-root',
      templateUrl: './app.component.html',
      styleUrls: ['./app.component.css']
    })
    
    export class AppComponent {
      title = 'angulartest';
    }
    
This file defines the stylesheet (css) and the content (html) and the class AppComponent which contains the logic or the data for the view.  

    export class AppComponent {
      title = 'angulartest';
    }

In the class AppComponent, we have a property => `title` which is assigned with 'angulartest' (the name of the project that I set when I use the CMD : `ng new angulartest`)   

### 4.app.component.html && app.component.css

This two files defines the content and the style of the view.  
	
	// app.component.html 
    <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
    <!-- * * * * * * * * * * * The content below * * * * * * * * * * * -->
    <!-- * * * * * * * * * * is only a placeholder * * * * * * * * * * -->
    <!-- * * * * * * * * * * and can be replaced. * * * * * * * * * * * -->
    <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
    <!-- * * * * * * * * * Delete the template below * * * * * * * * * * -->
    <!-- * * * * * * * to get started with your project! * * * * * * * * -->
    <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
    
    many verbose lines were Omiited.
    
    <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
    <!-- * * * * * * * * * * * The content above * * * * * * * * * * * -->
    <!-- * * * * * * * * * * is only a placeholder * * * * * * * * * * -->
    <!-- * * * * * * * * * * and can be replaced. * * * * * * * * * * * -->
    <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
    <!-- * * * * * * * * * * End of Placeholder * * * * * * * * * * * -->
    <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * -->
    
    
    
    <router-outlet></router-outlet>

And then the `<span>{{ title }} app is running!</span>` in the `app.component.html` file will finally replace the `{{ title }}` with the data defined in the `app.component.ts` file (`export class AppComponent { title = 'angulartest';}`, namely by 'angulartest'). At the same time, other static html elements will also get rendered in the broswer.  
   
After We use `ng serve` to start the project, we will finally see the effects look like below:  

![app-running](https://i.imgur.com/02AhCqQ.png)  

And as angular will auto-detect changes in the code. Like if we change the project name to `changed-name-app` in the `app.component.ts`, then it will automatically re-render the page without re-compiling the project :   

![name-changed](https://i.imgur.com/5nqk7mf.png)  

### 5. conclusion
When we type the `ng serve`, what is really happening behind the sence is that the executor first moves to the `main.ts` => `app.component.ts` => `app.component.html` && `app.component.css`=> find the variable 'title' in the `app.component.ts` => render the view => show in broswer.  
Different components represent the different views of the broswer, and they make up a major portion of the final angular application. In the following notes, I will take a more detailed look at components.  
  